<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js AR - Hit Test with Anchors and Buttons</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            font-family: sans-serif;
            font-size: 14px;
            color: #fff;
            z-index: 1;
            pointer-events: none; /* No interaction needed */
        }
        .button-container {
            position: fixed;
            bottom: 50px;
            left: 10px;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 8px;
            pointer-events: auto;
        }
        button {
            padding: 10px;
            background-color: green;
            color: white;
            font-size: 16px;
            border: none;
            cursor: pointer;
            width: 100px;
        }
        #toggle-buttons {
            position: fixed;
            bottom: 10px;
            left: 10px;
            z-index: 9999;
            padding: 10px;
            background-color: blue;
            color: white;
            font-size: 16px;
            border: none;
            cursor: pointer;
            pointer-events: auto;
        }
    </style>
</head>
<body>

<div id="info">
    <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> AR - Hit Test with Anchors<br />(Chrome Android 81+)
</div>

<!-- Button window -->
<div class="button-container" id="button-container">
    <button onclick="moveModel('x', 0.1)">Move X+</button>
    <button onclick="moveModel('x', -0.1)">Move X-</button>
    <button onclick="moveModel('y', 0.1)">Move Y+</button>
    <button onclick="moveModel('y', -0.1)">Move Y-</button>
    <button onclick="moveModel('z', 0.1)">Move Z+</button>
    <button onclick="moveModel('z', -0.1)">Move Z-</button>
    <button onclick="scaleModel(0.1)">Scale +</button>
    <button onclick="scaleModel(-0.1)">Scale -</button>
    <button onclick="rotateModel(0.1)">Rotate Y+</button> <!-- New Rotate Y+ button -->
    <button onclick="rotateModel(-0.1)">Rotate Y-</button> <!-- New Rotate Y- button -->
    <button onclick="hitAndAnchor()">Hit/Anchor</button> <!-- Hit/Anchor button -->
</div>
<button id="toggle-buttons" onclick="toggleButtonWindow()">Minimize</button>

<script type="module">
    import * as THREE from 'https://esm.sh/three@0.168.0';
    import { GLTFLoader } from 'https://esm.sh/three@0.168.0/examples/jsm/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'https://esm.sh/three@0.168.0/examples/jsm/loaders/DRACOLoader.js';
    import { ARButton } from 'https://esm.sh/three@0.168.0/examples/jsm/webxr/ARButton.js';

    let camera, scene, renderer, reticle, gltfModel, model, sphere;
    let hitTestSource = null;
    let hitTestSourceRequested = false;
    let modelPlaced = false;

    init();
    animate();

    function init() {
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

                    // Function to calculate the bounding box of the model and add directional lights based on its orientation
                    function addLightsBasedOnBoundingBox(model) {
                        // Compute the bounding box of the model in world coordinates
                        const box = new THREE.Box3().setFromObject(model);
                    
                        // Get the 8 corner points of the bounding box
                        const cornerPoints = [
                            new THREE.Vector3(box.min.x, box.min.y, box.min.z), // Bottom-front-left
                            new THREE.Vector3(box.min.x, box.min.y, box.max.z), // Bottom-back-left
                            new THREE.Vector3(box.max.x, box.min.y, box.min.z), // Bottom-front-right
                            new THREE.Vector3(box.max.x, box.min.y, box.max.z), // Bottom-back-right
                            new THREE.Vector3(box.min.x, box.max.y, box.min.z), // Top-front-left
                            new THREE.Vector3(box.min.x, box.max.y, box.max.z), // Top-back-left
                            new THREE.Vector3(box.max.x, box.max.y, box.min.z), // Top-front-right
                            new THREE.Vector3(box.max.x, box.max.y, box.max.z), // Top-back-right
                        ];
                    
                        // Compute the center of the bounding box
                        const center = new THREE.Vector3();
                        box.getCenter(center);
                    
                        // Adjust light intensities based on the model's size
                        const size = new THREE.Vector3();
                        box.getSize(size);
                        const intensityScale = 10;
                    
                        // Ambient light for overall brightness
                        const ambientLight = new THREE.AmbientLight(0xffffff, 1.5 * intensityScale);
                        scene.add(ambientLight);
                    
                        // Hemisphere light: Light from above and below
                        const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 1.5 * intensityScale);
                        hemisphereLight.position.set(center.x, size.y * 1/2, center.z); // Above the model
                        scene.add(hemisphereLight);
                    
                        // Add directional lights from the 8 corner points, pointing toward the center
                        for (let i = 0; i < cornerPoints.length; i++) {
                            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5 * intensityScale);
                    
                            // Set the position of the light to the corner point
                            directionalLight.position.copy(cornerPoints[i]);
                    
                            // Calculate the direction vector: (center - corner point)
                            const direction = new THREE.Vector3().subVectors(center, cornerPoints[i]).normalize();
                    
                            // Set the light's target to the center of the model
                            directionalLight.target.position.copy(center);
                            scene.add(directionalLight.target);  // Directional lights need a target in the scene
                    
                            // Add the directional light to the scene
                            scene.add(directionalLight);
                    
                            // Optionally, visualize the light with a helper
                            const helper = new THREE.DirectionalLightHelper(directionalLight);
                            scene.add(helper);
                            }

                                // Directional light from below to light the model's underside
                            const groundDirectionalLight = new THREE.DirectionalLight(0xffffff, 1.5 * intensityScale);
                            groundDirectionalLight.position.set(center.x, -size.y, center.z); // Position it below the model
                            groundDirectionalLight.target.position.set(center.x, center.y, center.z); // Target the center of the model
                            scene.add(groundDirectionalLight);
                            scene.add(groundDirectionalLight.target); // Important to add the target to the scene

                        
                        // RectAreaLight based on the bounding box (lighting from below)
                        const rectLight = new THREE.RectAreaLight(0xffffff, 1.0 * intensityScale, size.x, size.z);
                        rectLight.position.set(center.x, -size.y / 2, center.z); // Below the model
                        rectLight.lookAt(center.x, center.y, center.z); // Point the light toward the center of the model
                        scene.add(rectLight);
                        }    

        // Renderer with DOM Overlay support
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Add AR button with DOM Overlay and anchor support
        const arButton = ARButton.createButton(renderer, {
            requiredFeatures: ['hit-test', 'dom-overlay'],
            optionalFeatures: ['anchors'],
            domOverlay: { root: document.body } // Add buttons to the DOM overlay
        });
        document.body.appendChild(arButton);

        // Change the AR button style to make it blue or darker
        arButton.style.backgroundColor = 'blue'; // or use a darker color like '#333'
        arButton.style.color = 'white'; // Change text color to white for better contrast

        // Reticle for detecting planes
        reticle = new THREE.Mesh(
            new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
            new THREE.MeshBasicMaterial({ color: 0x0fff00 })
        );
        reticle.matrixAutoUpdate = false;
        reticle.visible = false;
        scene.add(reticle);

        // Initialize GLTFLoader with DRACOLoader for compressed models
        const loader = new GLTFLoader();
        const dracoLoader = new DRACOLoader();
         // Use JSDelivr for the Draco decoder files
        dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/libs/draco/');
        loader.setDRACOLoader(dracoLoader);


        // Function to adjust the material of the model to ensure it's light-reactive
function makeMaterialsLightReactive(model) {
    model.traverse(function (child) {
        if (child.isMesh) {
            // Check if the mesh has a material
            if (child.material) {
                // Convert the material to MeshStandardMaterial if needed
                if (!(child.material instanceof THREE.MeshStandardMaterial)) {
                    child.material = new THREE.MeshStandardMaterial({
                        color: child.material.color || 0xffffff, // Preserve the original color
                        metalness: 0.1,  // Adjust metalness
                        roughness: 0.8,  // Adjust roughness
                        side: THREE.DoubleSide // Ensure it's double-sided to prevent black faces
                    });
                }
            }
        }
    });
}

        
        // Load the Draco-compressed GLTF model
        loader.load('https://zunuk.github.io/testni/Finito4.glb', function (gltf) {
            gltfModel = gltf.scene;
            gltfModel.scale.set(1.0, 1.0, 1.0); // Initial scale


        // Adjust materials to be light-reactive
    makeMaterialsLightReactive(gltfModel);
            
        // Adjust lights based on the model's bounding box corner points
        addLightsBasedOnBoundingBox(gltfModel);
        
        }, undefined, function (error) {
            console.error('Error loading model:', error);
        });

        window.addEventListener('resize', onWindowResize);
    }

    // Function for hit-test and anchor logic
    async function hitAndAnchor() {
        const session = renderer.xr.getSession();
        const referenceSpace = renderer.xr.getReferenceSpace();

        if (!modelPlaced && reticle.visible && gltfModel) {
            // Place the model
            model = gltfModel.clone();
            reticle.matrix.decompose(model.position, model.quaternion, model.scale);
            scene.add(model);

            // Add a red sphere to indicate the anchor point
            sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 32, 32),  // 0.5m diameter
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            sphere.position.copy(model.position);  // Place sphere at the model's position
            scene.add(sphere);

            modelPlaced = true;
            console.log("Model placed and anchored.");

            // Anchor at the hit-test location
            const hitTestResults = session.requestHitTestSourceResults();

            if (hitTestResults && hitTestResults.length > 0) {
                const hit = hitTestResults[0];
                const anchorPose = hit.getPose(referenceSpace);

                try {
                    const anchor = await session.requestAnchor(anchorPose.transform.matrix, hit.anchorSpace);
                    console.log("Anchor created.");
                } catch (err) {
                    console.error("Error creating anchor:", err);
                }
            }
        } else if (modelPlaced) {
            // Unanchor and remove the model
            scene.remove(model);
            scene.remove(sphere);
            model = null;
            sphere = null;
            modelPlaced = false;
            console.log("Model unanchored and removed.");
        }
    }

    // Function to move the model in the specified axis
    function moveModel(axis, value) {
        if (model) {
            model.position[axis] += value;
            sphere.position[axis] += value;  // Keep sphere in sync
            console.log(`Model moved along ${axis} by ${value}`);
        }
    }

    // Function to scale the model
    function scaleModel(value) {
        if (model) {
            const newScale = Math.max(0.1, model.scale.x + value);
            model.scale.set(newScale, newScale, newScale);
            console.log("Model scaled to", newScale);
        }
    }

    // Function to rotate the model about the Y-axis
    function rotateModel(value) {
        if (model) {
            model.rotation.y += value;
            console.log(`Model rotated by ${value} radians`);
        }
    }

    // Handle window resize
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Animation loop
    function animate(timestamp, frame) {
        if (frame) {
            const referenceSpace = renderer.xr.getReferenceSpace();
            const session = renderer.xr.getSession();

            if (hitTestSourceRequested === false) {
                session.requestReferenceSpace('viewer').then(function (referenceSpace) {
                    session.requestHitTestSource({ space: referenceSpace }).then(function (source) {
                        hitTestSource = source;
                        hitTestSourceRequested = true;
                    });
                });
            }

            if (hitTestSource) {
                const hitTestResults = frame.getHitTestResults(hitTestSource);
                if (hitTestResults.length) {
                    const hit = hitTestResults[0];
                    reticle.visible = true;
                    reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                    reticle.updateMatrixWorld();
                } else {
                    reticle.visible = false;
                }
            }
        }

        renderer.render(scene, camera);
    }

    renderer.setAnimationLoop(animate);

    // Minimize or maximize the button container
    function toggleButtonWindow() {
        const buttonContainer = document.getElementById('button-container');
        const toggleButton = document.getElementById('toggle-buttons');

        if (buttonContainer.style.display === 'none') {
            buttonContainer.style.display = 'flex';
            toggleButton.textContent = 'Minimize';
        } else {
            buttonContainer.style.display = 'none';
            toggleButton.textContent = 'Maximize';
        }
    }

    // Make functions globally accessible
    window.moveModel = moveModel;
    window.scaleModel = scaleModel;
    window.rotateModel = rotateModel;
    window.hitAndAnchor = hitAndAnchor;
    window.toggleButtonWindow = toggleButtonWindow;
</script>

</body>
</html>
